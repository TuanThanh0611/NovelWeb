import { inject, DestroyRef, Injector, signal, computed, effect } from '@angular/core';
import { toObservable, takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { connect } from 'ngxtension/connect';
import { createNotifier } from 'ngxtension/create-notifier';
import { isObservable, Subject, share, take } from 'rxjs';

function signalSlice(config) {
    const destroyRef = inject(DestroyRef);
    const injector = inject(Injector);
    const { initialState, sources = [], lazySources = [], actionSources = {}, selectors = (() => ({})), effects = (() => ({})), } = config;
    const state = signal(initialState);
    const readonlyState = state.asReadonly();
    const state$ = toObservable(state);
    let lazySourcesLoaded = false;
    const subs = [];
    const slice = readonlyState;
    for (const [key, actionSource] of Object.entries(actionSources)) {
        if (isObservable(actionSource)) {
            addReducerProperties(readonlyState, state$, key, destroyRef, actionSource, subs);
        }
        else {
            const subject = new Subject();
            const observable = actionSource(readonlyState, subject);
            const sharedObservable = observable.pipe(share());
            connect(state, sharedObservable);
            addReducerProperties(readonlyState, state$, key, destroyRef, subject, subs, sharedObservable);
        }
    }
    for (const key in initialState) {
        const value = computed(() => readonlyState()[key]);
        Object.defineProperty(readonlyState, key, {
            value,
        });
        readonlyState[`${key}$`] = toObservable(value);
    }
    for (const [key, selector] of Object.entries(selectors(slice))) {
        const value = computed(selector);
        Object.defineProperty(readonlyState, key, {
            value,
        });
        readonlyState[`${key}$`] = toObservable(value);
    }
    for (const [key, namedEffect] of Object.entries(effects(slice))) {
        console.warn("The 'effects' configuration in signalSlice is deprecated. Please use standard signal effects outside of signalSlice instead.");
        Object.defineProperty(slice, key, {
            value: effect((onCleanup) => {
                const maybeCleanup = namedEffect();
                if (maybeCleanup) {
                    onCleanup(() => maybeCleanup());
                }
            }),
        });
    }
    connectSources(state, sources, readonlyState);
    destroyRef.onDestroy(() => {
        subs.forEach((sub) => sub.complete());
    });
    const connectLazySources = () => {
        if (!lazySourcesLoaded) {
            lazySourcesLoaded = true;
            connectSources(state, lazySources, readonlyState, injector, true);
        }
    };
    return new Proxy(slice, {
        get(target, property, receiver) {
            connectLazySources();
            return Reflect.get(target, property, receiver);
        },
        apply(target, thisArg, argumentsList) {
            connectLazySources();
            return Reflect.apply(target, thisArg, argumentsList);
        },
    });
}
function connectSources(state, sources, readonlyState, injector, useUntracked = false) {
    for (const source of sources) {
        if (isObservable(source)) {
            connect(state, source, injector, useUntracked);
        }
        else {
            connect(state, source(readonlyState), injector, useUntracked);
        }
    }
}
function addReducerProperties(readonlyState, state$, key, destroyRef, subject, subs, observableFromActionSource) {
    const version = createNotifier();
    Object.defineProperties(readonlyState, {
        [key]: {
            value: (nextValue) => {
                if (isObservable(nextValue)) {
                    return new Promise((res, rej) => {
                        nextValue.pipe(takeUntilDestroyed(destroyRef)).subscribe({
                            next: (value) => {
                                version.notify();
                                subject.next(value);
                            },
                            error: (err) => {
                                subject.error(err);
                                rej(err);
                            },
                            complete: () => {
                                version.notify();
                                subject.complete();
                                res(readonlyState());
                            },
                        });
                    });
                }
                if (observableFromActionSource) {
                    observableFromActionSource
                        .pipe(takeUntilDestroyed(destroyRef))
                        .subscribe();
                }
                return new Promise((res) => {
                    state$.pipe(take(1)).subscribe((val) => {
                        res(val);
                    });
                    version.notify();
                    subject.next(nextValue);
                });
            },
        },
        [`${key}$`]: {
            value: subject.asObservable(),
        },
        [`${key}Updated`]: {
            value: version.listen,
        },
    });
    subs.push(subject);
}

/**
 * Generated bundle index. Do not edit.
 */

export { signalSlice };
//# sourceMappingURL=ngxtension-signal-slice.mjs.map
