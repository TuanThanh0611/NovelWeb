import { DOCUMENT } from '@angular/common';
import { DestroyRef, Directive, ElementRef, EventEmitter, Input, NgZone, Output, inject, } from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { createInjectionToken } from 'ngxtension/create-injection-token';
import { Observable, ReplaySubject, debounceTime, fromEvent, pipe, share, takeUntil, } from 'rxjs';
import * as i0 from "@angular/core";
export const defaultResizeOptions = {
    box: 'content-box',
    scroll: false,
    offsetSize: false,
    debounce: { scroll: 50, resize: 0 },
    emitInZone: true,
    emitInitialResult: false,
};
export const [injectResizeOptions, provideResizeOptions, NGX_RESIZE_OPTIONS] = createInjectionToken(() => defaultResizeOptions);
/**
 * `injectResize` returns an `Observable<ResizeResult>` that observes the `resize` event on the Host element
 * of the component. `options` passed in is merged with default options
 *
 * @see {@link defaultResizeOptions}
 *
 * @param {Partial<ResizeOptions>} [options={}]
 * @see {@link ResizeOptions}
 *
 * @returns {Observable<ResizeResult>}
 * @see {@link ResizeResult}
 */
export function injectResize(options = {}) {
    const [{ nativeElement }, zone, document] = [
        inject(ElementRef),
        inject(NgZone),
        inject(DOCUMENT),
    ];
    const mergedOptions = { ...injectResizeOptions(), ...options };
    return createResizeStream(mergedOptions, nativeElement, document, zone);
}
/**
 * A directive to be used on any element instead of the Host element. For Host element, there are 3 approaches:
 * - use {@link injectResize}
 * - use `hostDirectives`  with `HostListener` on `ngxResize`
 *
 * @param {Partial<ResizeOptions>} - partial options to control `Resize` behavior. merged with default options
 * @see {@link defaultResizeOptions}
 *
 * @returns {ResizeResult} - as an Output `(ngxResize)`
 */
export class NgxResize {
    constructor() {
        this.ngxResizeOptions = {};
        this.ngxResize = new EventEmitter();
        this.host = inject(ElementRef);
        this.zone = inject(NgZone);
        this.document = inject(DOCUMENT);
        this.resizeOptions = injectResizeOptions();
        this.destroyRef = inject(DestroyRef);
    }
    ngOnInit() {
        const mergedOptions = { ...this.resizeOptions, ...this.ngxResizeOptions };
        createResizeStream(mergedOptions, this.host.nativeElement, this.document, this.zone)
            .pipe(takeUntilDestroyed(this.destroyRef))
            .subscribe(this.ngxResize);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.7", ngImport: i0, type: NgxResize, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.2.7", type: NgxResize, isStandalone: true, selector: "[ngxResize]", inputs: { ngxResizeOptions: "ngxResizeOptions" }, outputs: { ngxResize: "ngxResize" }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.7", ngImport: i0, type: NgxResize, decorators: [{
            type: Directive,
            args: [{ selector: '[ngxResize]', standalone: true }]
        }], propDecorators: { ngxResizeOptions: [{
                type: Input
            }], ngxResize: [{
                type: Output
            }] } });
// return ResizeResult observable
function createResizeStream({ debounce, scroll, offsetSize, box, emitInZone, emitInitialResult, }, nativeElement, document, zone) {
    const window = document.defaultView;
    const screen = window?.screen;
    const isSupport = !!window?.ResizeObserver;
    let observer;
    let lastBounds;
    let lastEntries = [];
    const torndown$ = new ReplaySubject();
    const scrollContainers = findScrollContainers(nativeElement, window, document.body);
    // set actual debounce values early, so effects know if they should react accordingly
    const scrollDebounce = debounce
        ? typeof debounce === 'number'
            ? debounce
            : debounce.scroll
        : null;
    const resizeDebounce = debounce
        ? typeof debounce === 'number'
            ? debounce
            : debounce.resize
        : null;
    const debounceAndTorndown = (debounce) => {
        return pipe(debounceTime(debounce ?? 0), takeUntil(torndown$));
    };
    return new Observable((subscriber) => {
        if (!isSupport) {
            subscriber.error('[ngx-resize] your browser does not support ResizeObserver. Please consider using a polyfill');
            return;
        }
        zone.runOutsideAngular(() => {
            if (emitInitialResult) {
                const [result] = calculateResult(nativeElement, window, offsetSize, []);
                if (emitInZone)
                    zone.run(() => void subscriber.next(result));
                else
                    subscriber.next(result);
            }
            const callback = (entries) => {
                lastEntries = entries;
                const [result, size] = calculateResult(nativeElement, window, offsetSize, entries);
                if (emitInZone)
                    zone.run(() => void subscriber.next(result));
                else
                    subscriber.next(result);
                if (!areBoundsEqual(lastBounds || {}, size))
                    lastBounds = size;
            };
            const boundCallback = () => void callback(lastEntries);
            observer = new ResizeObserver(callback);
            observer.observe(nativeElement, { box });
            if (scroll) {
                if (scrollContainers) {
                    scrollContainers.forEach((scrollContainer) => {
                        fromEvent(scrollContainer, 'scroll', {
                            capture: true,
                            passive: true,
                        })
                            .pipe(debounceAndTorndown(scrollDebounce))
                            .subscribe(boundCallback);
                    });
                }
                fromEvent(window, 'scroll', { capture: true, passive: true })
                    .pipe(debounceAndTorndown(scrollDebounce))
                    .subscribe(boundCallback);
            }
            fromEvent(window, 'resize')
                .pipe(debounceAndTorndown(resizeDebounce))
                .subscribe(boundCallback);
            if (screen &&
                'orientation' in screen &&
                'addEventListener' in screen.orientation) {
                fromEvent(screen.orientation, 'change')
                    .pipe(debounceAndTorndown(scrollDebounce))
                    .subscribe(boundCallback);
            }
            else if (window && 'orientationchange' in window) {
                fromEvent(window, 'orientationchange')
                    .pipe(debounceAndTorndown(scrollDebounce))
                    .subscribe(boundCallback);
            }
        });
        return () => {
            if (observer) {
                observer.unobserve(nativeElement);
                observer.disconnect();
            }
            torndown$.next();
            torndown$.complete();
        };
    }).pipe(debounceTime(scrollDebounce ?? 0), share({ connector: () => new ReplaySubject(1) }));
}
function calculateResult(nativeElement, window, offsetSize, entries) {
    const { left, top, width, height, bottom, right, x, y } = nativeElement.getBoundingClientRect();
    const size = { left, top, width, height, bottom, right, x, y };
    if (nativeElement instanceof HTMLElement && offsetSize) {
        size.height = nativeElement.offsetHeight;
        size.width = nativeElement.offsetWidth;
    }
    Object.freeze(size);
    return [{ entries, dpr: window.devicePixelRatio, ...size }, size];
}
// Returns a list of scroll offsets
function findScrollContainers(element, window, documentBody) {
    const result = [];
    if (!element || !window || element === documentBody)
        return result;
    const { overflow, overflowX, overflowY } = window.getComputedStyle(element);
    if ([overflow, overflowX, overflowY].some((prop) => prop === 'auto' || prop === 'scroll'))
        result.push(element);
    return [
        ...result,
        ...findScrollContainers(element.parentElement, window, documentBody),
    ];
}
// Checks if element boundaries are equal
const keys = [
    'x',
    'y',
    'top',
    'bottom',
    'left',
    'right',
    'width',
    'height',
];
const areBoundsEqual = (a, b) => keys.every((key) => a[key] === b[key]);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVzaXplLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vbGlicy9uZ3h0ZW5zaW9uL3Jlc2l6ZS9zcmMvcmVzaXplLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUMzQyxPQUFPLEVBQ04sVUFBVSxFQUNWLFNBQVMsRUFDVCxVQUFVLEVBQ1YsWUFBWSxFQUNaLEtBQUssRUFDTCxNQUFNLEVBQ04sTUFBTSxFQUNOLE1BQU0sR0FFTixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQUNoRSxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxtQ0FBbUMsQ0FBQztBQUN6RSxPQUFPLEVBQ04sVUFBVSxFQUNWLGFBQWEsRUFDYixZQUFZLEVBQ1osU0FBUyxFQUNULElBQUksRUFDSixLQUFLLEVBQ0wsU0FBUyxHQUVULE1BQU0sTUFBTSxDQUFDOztBQVdkLE1BQU0sQ0FBQyxNQUFNLG9CQUFvQixHQUFrQjtJQUNsRCxHQUFHLEVBQUUsYUFBYTtJQUNsQixNQUFNLEVBQUUsS0FBSztJQUNiLFVBQVUsRUFBRSxLQUFLO0lBQ2pCLFFBQVEsRUFBRSxFQUFFLE1BQU0sRUFBRSxFQUFFLEVBQUUsTUFBTSxFQUFFLENBQUMsRUFBRTtJQUNuQyxVQUFVLEVBQUUsSUFBSTtJQUNoQixpQkFBaUIsRUFBRSxLQUFLO0NBQ3hCLENBQUM7QUFFRixNQUFNLENBQUMsTUFBTSxDQUFDLG1CQUFtQixFQUFFLG9CQUFvQixFQUFFLGtCQUFrQixDQUFDLEdBQzNFLG9CQUFvQixDQUFDLEdBQUcsRUFBRSxDQUFDLG9CQUFvQixDQUFDLENBQUM7QUFlbEQ7Ozs7Ozs7Ozs7O0dBV0c7QUFDSCxNQUFNLFVBQVUsWUFBWSxDQUMzQixVQUFrQyxFQUFFO0lBRXBDLE1BQU0sQ0FBQyxFQUFFLGFBQWEsRUFBRSxFQUFFLElB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LENBQUMsYUFBYSxFQUN0QyxNQUFNLEVBQ04sWUFBWSxDQUNaO0tBQ0QsQ0FBQztBQUNILENBQUM7QUFFRCx5Q0FBeUM7QUFDekMsTUFBTSxJQUFJLEdBQW9EO0lBQzdELEdBQUc7SUFDSCxHQUFHO0lBQ0gsS0FBSztJQUNMLFFBQVE7SUFDUixNQUFNO0lBQ04sT0FBTztJQUNQLE9BQU87SUFDUCxRQUFRO0NBQ1IsQ0FBQztBQUNGLE1BQU0sY0FBYyxHQUFHLENBQ3RCLENBQXdDLEVBQ3hDLENBQXdDLEVBQ3ZDLEVBQUUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBET0NVTUVOVCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge1xuXHREZXN0cm95UmVmLFxuXHREaXJlY3RpdmUsXG5cdEVsZW1lbnRSZWYsXG5cdEV2ZW50RW1pdHRlcixcblx0SW5wdXQsXG5cdE5nWm9uZSxcblx0T3V0cHV0LFxuXHRpbmplY3QsXG5cdHR5cGUgT25Jbml0LFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IHRha2VVbnRpbERlc3Ryb3llZCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUvcnhqcy1pbnRlcm9wJztcbmltcG9ydCB7IGNyZWF0ZUluamVjdGlvblRva2VuIH0gZnJvbSAnbmd4dGVuc2lvbi9jcmVhdGUtaW5qZWN0aW9uLXRva2VuJztcbmltcG9ydCB7XG5cdE9ic2VydmFibGUsXG5cdFJlcGxheVN1YmplY3QsXG5cdGRlYm91bmNlVGltZSxcblx0ZnJvbUV2ZW50LFxuXHRwaXBlLFxuXHRzaGFyZSxcblx0dGFrZVVudGlsLFxuXHR0eXBlIE1vbm9UeXBlT3BlcmF0b3JGdW5jdGlvbixcbn0gZnJvbSAncnhqcyc7XG5cbmV4cG9ydCB0eXBlIFJlc2l6ZU9wdGlvbnMgPSB7XG5cdGJveDogUmVzaXplT2JzZXJ2ZXJCb3hPcHRpb25zO1xuXHRkZWJvdW5jZTogbnVtYmVyIHwgeyBzY3JvbGw6IG51bWJlcjsgcmVzaXplOiBudW1iZXIgfTtcblx0c2Nyb2xsOiBib29sZWFuO1xuXHRvZmZzZXRTaXplOiBib29sZWFuO1xuXHRlbWl0SW5ab25lOiBib29sZWFuO1xuXHRlbWl0SW5pdGlhbFJlc3VsdDogYm9vbGVhbjtcbn07XG5cbmV4cG9ydCBjb25zdCBkZWZhdWx0UmVzaXplT3B0aW9uczogUmVzaXplT3B0aW9ucyA9IHtcblx0Ym94OiAnY29udGVudC1ib3gnLFxuXHRzY3JvbGw6IGZhbHNlLFxuXHRvZmZzZXRTaXplOiBmYWxzZSxcblx0ZGVib3VuY2U6IHsgc2Nyb2xsOiA1MCwgcmVzaXplOiAwIH0sXG5cdGVtaXRJblpvbmU6IHRydWUsXG5cdGVtaXRJbml0aWFsUmVzdWx0OiBmYWxzZSxcbn07XG5cbmV4cG9ydCBjb25zdCBbaW5qZWN0UmVzaXplT3B0aW9ucywgcHJvdmlkZVJlc2l6ZU9wdGlvbnMsIE5HWF9SRVNJWkVfT1BUSU9OU10gPVxuXHRjcmVhdGVJbmplY3Rpb25Ub2tlbigoKSA9PiBkZWZhdWx0UmVzaXplT3B0aW9ucyk7XG5cbmV4cG9ydCB0eXBlIFJlc2l6ZVJlc3VsdCA9IHtcblx0cmVhZG9ubHkgZW50cmllczogUmVhZG9ubHlBcnJheTxSZXNpemVPYnNlcnZlckVudHJ5Pjtcblx0cmVhZG9ubHkgeDogbnVtYmVyO1xuXHRyZWFkb25seSB5OiBudW1iZXI7XG5cdHJlYWRvbmx5IHdpZHRoOiBudW1iZXI7XG5cdHJlYWRvbmx5IGhlaWdodDogbnVtYmVyO1xuXHRyZWFkb25seSB0b3A6IG51bWJlcjtcblx0cmVhZG9ubHkgcmlnaHQ6IG51bWJlcjtcblx0cmVhZG9ubHkgYm90dG9tOiBudW1iZXI7XG5cdHJlYWRvbmx5IGxlZnQ6IG51bWJlcjtcblx0cmVhZG9ubHkgZHByOiBudW1iZXI7XG59O1xuXG4vKipcbiAqIGBpbmplY3RSZXNpemVgIHJldHVybnMgYW4gYE9ic2VydmFibGU8UmVzaXplUmVzdWx0PmAgdGhhdCBvYnNlcnZlcyB0aGUgYHJlc2l6ZWAgZXZlbnQgb24gdGhlIEhvc3QgZWxlbWVudFxuICogb2YgdGhlIGNvbXBvbmVudC4gYG9wdGlvbnNgIHBhc3NlZCBpbiBpcyBtZXJnZWQgd2l0aCBkZWZhdWx0IG9wdGlvbnNcbiAqXG4gKiBAc2VlIHtAbGluayBkZWZhdWx0UmVzaXplT3B0aW9uc31cbiAqXG4gKiBAcGFyYW0ge1BhcnRpYWw8UmVzaXplT3B0aW9ucz59IFtvcHRpb25zPXt9XVxuICogQHNlZSB7QGxpbmsgUmVzaXplT3B0aW9uc31cbiAqXG4gKiBAcmV0dXJucyB7T2JzZXJ2YWJsZTxSZXNpemVSZXN1bHQ+fVxuICogQHNlZSB7QGxpbmsgUmVzaXplUmVzdWx0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5qZWN0UmVzaXplKFxuXHRvcHRpb25zOiBQYXJ0aWFsPFJlc2l6ZU9wdGlvbnM+ID0ge30sXG4pOiBPYnNlcnZhYmxlPFJlc2l6ZVJlc3VsdD4ge1xuXHRjb25zdCBbeyBuYXRpdmVFbGVtZW50IH0sIHpvbmUsIGRvY3VtZW50XSA9IFtcblx0XHRpbmplY3QoRWxlbWVudFJlZikgYXMgRWxlbWVudFJlZjxIVE1MRWxlbWVudD4sXG5cdFx0aW5qZWN0KE5nWm9uZSksXG5cdFx0aW5qZWN0KERPQ1VNRU5UKSxcblx0XTtcblx0Y29uc3QgbWVyZ2VkT3B0aW9ucyA9IHsgLi4uaW5qZWN0UmVzaXplT3B0aW9ucygpLCAuLi5vcHRpb25zIH07XG5cdHJldHVybiBjcmVhdGVSZXNpemVTdHJlYW0obWVyZ2VkT3B0aW9ucywgbmF0aXZlRWxlbWVudCwgZG9jdW1lbnQsIHpvbmUpO1xufVxuXG4vKipcbiAqIEEgZGlyZWN0aXZlIHRvIGJlIHVzZWQgb24gYW55IGVsZW1lbnQgaW5zdGVhZCBvZiB0aGUgSG9zdCBlbGVtZW50LiBGb3IgSG9zdCBlbGVtZW50LCB0aGVyZSBhcmUgMyBhcHByb2FjaGVzOlxuICogLSB1c2Uge0BsaW5rIGluamVjdFJlc2l6ZX1cbiAqIC0gdXNlIGBob3N0RGlyZWN0aXZlc2AgIHdpdGggYEhvc3RMaXN0ZW5lcmAgb24gYG5neFJlc2l6ZWBcbiAqXG4gKiBAcGFyYW0ge1BhcnRpYWw8UmVzaXplT3B0aW9ucz59IC0gcGFydGlhbCBvcHRpb25zIHRvIGNvbnRyb2wgYFJlc2l6ZWAgYmVoYXZpb3IuIG1lcmdlZCB3aXRoIGRlZmF1bHQgb3B0aW9uc1xuICogQHNlZSB7QGxpbmsgZGVmYXVsdFJlc2l6ZU9wdGlvbnN9XG4gKlxuICogQHJldHVybnMge1Jlc2l6ZVJlc3VsdH0gLSBhcyBhbiBPdXRwdXQgYChuZ3hSZXNpemUpYFxuICovXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbbmd4UmVzaXplXScsIHN0YW5kYWxvbmU6IHRydWUgfSlcbmV4cG9ydCBjbGFzcyBOZ3hSZXNpemUgaW1wbGVtZW50cyBPbkluaXQge1xuXHRASW5wdXQoKSBuZ3hSZXNpemVPcHRpb25zOiBQYXJ0aWFsPFJlc2l6ZU9wdGlvbnM+ID0ge307XG5cdEBPdXRwdXQoKSBuZ3hSZXNpemUgPSBuZXcgRXZlbnRFbWl0dGVyPFJlc2l6ZVJlc3VsdD4oKTtcblxuXHRwcml2YXRlIGhvc3QgPSBpbmplY3QoRWxlbWVudFJlZik7XG5cdHByaXZhdGUgem9uZSA9IGluamVjdChOZ1pvbmUpO1xuXHRwcml2YXRlIGRvY3VtZW50ID0gaW5qZWN0KERPQ1VNRU5UKTtcblx0cHJpdmF0ZSByZXNpemVPcHRpb25zID0gaW5qZWN0UmVzaXplT3B0aW9ucygpO1xuXHRwcml2YXRlIGRlc3Ryb3lSZWYgPSBpbmplY3QoRGVzdHJveVJlZik7XG5cblx0bmdPbkluaXQoKSB7XG5cdFx0Y29uc3QgbWVyZ2VkT3B0aW9ucyA9IHsgLi4udGhpcy5yZXNpemVPcHRpb25zLCAuLi50aGlzLm5neFJlc2l6ZU9wdGlvbnMgfTtcblx0XHRjcmVhdGVSZXNpemVTdHJlYW0oXG5cdFx0XHRtZXJnZWRPcHRpb25zLFxuXHRcdFx0dGhpcy5ob3N0Lm5hdGl2ZUVsZW1lbnQsXG5cdFx0XHR0aGlzLmRvY3VtZW50LFxuXHRcdFx0dGhpcy56b25lLFxuXHRcdClcblx0XHRcdC5waXBlKHRha2VVbnRpbERlc3Ryb3llZCh0aGlzLmRlc3Ryb3lSZWYpKVxuXHRcdFx0LnN1YnNjcmliZSh0aGlzLm5neFJlc2l6ZSk7XG5cdH1cbn1cblxuLy8gcmV0dXJuIFJlc2l6ZVJlc3VsdCBvYnNlcnZhYmxlXG5mdW5jdGlvbiBjcmVhdGVSZXNpemVTdHJlYW0oXG5cdHtcblx0XHRkZWJvdW5jZSxcblx0XHRzY3JvbGwsXG5cdFx0b2Zmc2V0U2l6ZSxcblx0XHRib3gsXG5cdFx0ZW1pdEluWm9uZSxcblx0XHRlbWl0SW5pdGlhbFJlc3VsdCxcblx0fTogUmVzaXplT3B0aW9ucyxcblx0bmF0aXZlRWxlbWVudDogSFRNTEVsZW1lbnQsXG5cdGRvY3VtZW50OiBEb2N1bWVudCxcblx0em9uZTogTmdab25lLFxuKSB7XG5cdGNvbnN0IHdpbmRvdyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3O1xuXHRjb25zdCBzY3JlZW4gPSB3aW5kb3c/LnNjcmVlbjtcblx0Y29uc3QgaXNTdXBwb3J0ID0gISF3aW5kb3c/LlJlc2l6ZU9ic2VydmVyO1xuXG5cdGxldCBvYnNlcnZlcjogUmVzaXplT2JzZXJ2ZXI7XG5cdGxldCBsYXN0Qm91bmRzOiBPbWl0PFJlc2l6ZVJlc3VsdCwgJ2VudHJpZXMnIHwgJ2Rwcic+O1xuXHRsZXQgbGFzdEVudHJpZXM6IFJlc2l6ZU9ic2VydmVyRW50cnlbXSA9IFtdO1xuXG5cdGNvbnN0IHRvcm5kb3duJCA9IG5ldyBSZXBsYXlTdWJqZWN0PHZvaWQ+KCk7XG5cdGNvbnN0IHNjcm9sbENvbnRhaW5lcnM6IEhUTUxPclNWR0VsZW1lbnRbXSB8IG51bGwgPSBmaW5kU2Nyb2xsQ29udGFpbmVycyhcblx0XHRuYXRpdmVFbGVtZW50LFxuXHRcdHdpbmRvdyxcblx0XHRkb2N1bWVudC5ib2R5LFxuXHQpO1xuXG5cdC8vIHNldCBhY3R1YWwgZGVib3VuY2UgdmFsdWVzIGVhcmx5LCBzbyBlZmZlY3RzIGtub3cgaWYgdGhleSBzaG91bGQgcmVhY3QgYWNjb3JkaW5nbHlcblx0Y29uc3Qgc2Nyb2xsRGVib3VuY2UgPSBkZWJvdW5jZVxuXHRcdD8gdHlwZW9mIGRlYm91bmNlID09PSAnbnVtYmVyJ1xuXHRcdFx0PyBkZWJvdW5jZVxuXHRcdFx0OiBkZWJvdW5jZS5zY3JvbGxcblx0XHQ6IG51bGw7XG5cdGNvbnN0IHJlc2l6ZURlYm91bmNlID0gZGVib3VuY2Vcblx0XHQ/IHR5cGVvZiBkZWJvdW5jZSA9PT0gJ251bWJlcidcblx0XHRcdD8gZGVib3VuY2Vcblx0XHRcdDogZGVib3VuY2UucmVzaXplXG5cdFx0OiBudWxsO1xuXG5cdGNvbnN0IGRlYm91bmNlQW5kVG9ybmRvd24gPSA8VD4oXG5cdFx0ZGVib3VuY2U6IG51bWJlciB8IG51bGwsXG5cdCk6IE1vbm9UeXBlT3BlcmF0b3JGdW5jdGlvbjxUPiA9PiB7XG5cdFx0cmV0dXJuIHBpcGUoZGVib3VuY2VUaW1lKGRlYm91bmNlID8/IDApLCB0YWtlVW50aWwodG9ybmRvd24kKSk7XG5cdH07XG5cblx0cmV0dXJuIG5ldyBPYnNlcnZhYmxlPFJlc2l6ZVJlc3VsdD4oKHN1YnNjcmliZXIpID0+IHtcblx0XHRpZiAoIWlzU3VwcG9ydCkge1xuXHRcdFx0c3Vic2NyaWJlci5lcnJvcihcblx0XHRcdFx0J1tuZ3gtcmVzaXplXSB5b3VyIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBSZXNpemVPYnNlcnZlci4gUGxlYXNlIGNvbnNpZGVyIHVzaW5nIGEgcG9seWZpbGwnLFxuXHRcdFx0KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR6b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcblx0XHRcdGlmIChlbWl0SW5pdGlhbFJlc3VsdCkge1xuXHRcdFx0XHRjb25zdCBbcmVzdWx0XSA9IGNhbGN1bGF0ZVJlc3VsdChuYXRpdmVFbGVtZW50LCB3aW5kb3csIG9mZnNldFNpemUsIFtdKTtcblx0XHRcdFx0aWYgKGVtaXRJblpvbmUpIHpvbmUucnVuKCgpID0+IHZvaWQgc3Vic2NyaWJlci5uZXh0KHJlc3VsdCkpO1xuXHRcdFx0XHRlbHNlIHN1YnNjcmliZXIubmV4dChyZXN1bHQpO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBjYWxsYmFjayA9IChlbnRyaWVzOiBSZXNpemVPYnNlcnZlckVudHJ5W10pID0+IHtcblx0XHRcdFx0bGFzdEVudHJpZXMgPSBlbnRyaWVzO1xuXHRcdFx0XHRjb25zdCBbcmVzdWx0LCBzaXplXSA9IGNhbGN1bGF0ZVJlc3VsdChcblx0XHRcdFx0XHRuYXRpdmVFbGVtZW50LFxuXHRcdFx0XHRcdHdpbmRvdyxcblx0XHRcdFx0XHRvZmZzZXRTaXplLFxuXHRcdFx0XHRcdGVudHJpZXMsXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0aWYgKGVtaXRJblpvbmUpIHpvbmUucnVuKCgpID0+IHZvaWQgc3Vic2NyaWJlci5uZXh0KHJlc3VsdCkpO1xuXHRcdFx0XHRlbHNlIHN1YnNjcmliZXIubmV4dChyZXN1bHQpO1xuXG5cdFx0XHRcdGlmICghYXJlQm91bmRzRXF1YWwobGFzdEJvdW5kcyB8fCB7fSwgc2l6ZSkpIGxhc3RCb3VuZHMgPSBzaXplO1xuXHRcdFx0fTtcblxuXHRcdFx0Y29uc3QgYm91bmRDYWxsYmFjayA9ICgpID0+IHZvaWQgY2FsbGJhY2sobGFzdEVudHJpZXMpO1xuXG5cdFx0XHRvYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihjYWxsYmFjayk7XG5cblx0XHRcdG9ic2VydmVyLm9ic2VydmUobmF0aXZlRWxlbWVudCwgeyBib3ggfSk7XG5cdFx0XHRpZiAoc2Nyb2xsKSB7XG5cdFx0XHRcdGlmIChzY3JvbGxDb250YWluZXJzKSB7XG5cdFx0XHRcdFx0c2Nyb2xsQ29udGFpbmVycy5mb3JFYWNoKChzY3JvbGxDb250YWluZXIpID0+IHtcblx0XHRcdFx0XHRcdGZyb21FdmVudChzY3JvbGxDb250YWluZXIgYXMgSFRNTEVsZW1lbnQsICdzY3JvbGwnLCB7XG5cdFx0XHRcdFx0XHRcdGNhcHR1cmU6IHRydWUsXG5cdFx0XHRcdFx0XHRcdHBhc3NpdmU6IHRydWUsXG5cdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdFx0XHQucGlwZShkZWJvdW5jZUFuZFRvcm5kb3duKHNjcm9sbERlYm91bmNlKSlcblx0XHRcdFx0XHRcdFx0LnN1YnNjcmliZShib3VuZENhbGxiYWNrKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZyb21FdmVudCh3aW5kb3csICdzY3JvbGwnLCB7IGNhcHR1cmU6IHRydWUsIHBhc3NpdmU6IHRydWUgfSlcblx0XHRcdFx0XHQucGlwZShkZWJvdW5jZUFuZFRvcm5kb3duKHNjcm9sbERlYm91bmNlKSlcblx0XHRcdFx0XHQuc3Vic2NyaWJlKGJvdW5kQ2FsbGJhY2spO1xuXHRcdFx0fVxuXG5cdFx0XHRmcm9tRXZlbnQod2luZG93LCAncmVzaXplJylcblx0XHRcdFx0LnBpcGUoZGVib3VuY2VBbmRUb3JuZG93bihyZXNpemVEZWJvdW5jZSkpXG5cdFx0XHRcdC5zdWJzY3JpYmUoYm91bmRDYWxsYmFjayk7XG5cblx0XHRcdGlmIChcblx0XHRcdFx0c2NyZWVuICYmXG5cdFx0XHRcdCdvcmllbnRhdGlvbicgaW4gc2NyZWVuICYmXG5cdFx0XHRcdCdhZGRFdmVudExpc3RlbmVyJyBpbiBzY3JlZW4ub3JpZW50YXRpb25cblx0XHRcdCkge1xuXHRcdFx0XHRmcm9tRXZlbnQoc2NyZWVuLm9yaWVudGF0aW9uLCAnY2hhbmdlJylcblx0XHRcdFx0XHQucGlwZShkZWJvdW5jZUFuZFRvcm5kb3duKHNjcm9sbERlYm91bmNlKSlcblx0XHRcdFx0XHQuc3Vic2NyaWJlKGJvdW5kQ2FsbGJhY2spO1xuXHRcdFx0fSBlbHNlIGlmICh3aW5kb3cgJiYgJ29yaWVudGF0aW9uY2hhbmdlJyBpbiB3aW5kb3cpIHtcblx0XHRcdFx0ZnJvbUV2ZW50KHdpbmRvdywgJ29yaWVudGF0aW9uY2hhbmdlJylcblx0XHRcdFx0XHQucGlwZShkZWJvdW5jZUFuZFRvcm5kb3duKHNjcm9sbERlYm91bmNlKSlcblx0XHRcdFx0XHQuc3Vic2NyaWJlKGJvdW5kQ2FsbGJhY2spO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuICgpID0+IHtcblx0XHRcdGlmIChvYnNlcnZlcikge1xuXHRcdFx0XHRvYnNlcnZlci51bm9ic2VydmUobmF0aXZlRWxlbWVudCk7XG5cdFx0XHRcdG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcblx0XHRcdH1cblx0XHRcdHRvcm5kb3duJC5uZXh0KCk7XG5cdFx0XHR0b3JuZG93biQuY29tcGxldGUoKTtcblx0XHR9O1xuXHR9KS5waXBlKFxuXHRcdGRlYm91bmNlVGltZShzY3JvbGxEZWJvdW5jZSA/PyAwKSxcblx0XHRzaGFyZSh7IGNvbm5lY3RvcjogKCkgPT4gbmV3IFJlcGxheVN1YmplY3QoMSkgfSksXG5cdCk7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVJlc3VsdChcblx0bmF0aXZlRWxlbWVudDogSFRNTEVsZW1lbnQsXG5cdHdpbmRvdzogV2luZG93LFxuXHRvZmZzZXRTaXplOiBib29sZWFuLFxuXHRlbnRyaWVzOiBSZXNpemVPYnNlcnZlckVudHJ5W10sXG4pOiBbUmVzaXplUmVzdWx0LCBPbWl0PERPTVJlY3QsICd0b0pTT04nPl0ge1xuXHRjb25zdCB7IGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCwgYm90dG9tLCByaWdodCwgeCwgeSB9ID1cblx0XHRuYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRjb25zdCBzaXplID0geyBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQsIGJvdHRvbSwgcmlnaHQsIHgsIHkgfTtcblxuXHRpZiAobmF0aXZlRWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIG9mZnNldFNpemUpIHtcblx0XHRzaXplLmhlaWdodCA9IG5hdGl2ZUVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuXHRcdHNpemUud2lkdGggPSBuYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoO1xuXHR9XG5cblx0T2JqZWN0LmZyZWV6ZShzaXplKTtcblx0cmV0dXJuIFt7IGVudHJpZXMsIGRwcjogd2luZG93LmRldmljZVBpeGVsUmF0aW8sIC4uLnNpemUgfSwgc2l6ZV07XG59XG5cbi8vIFJldHVybnMgYSBsaXN0IG9mIHNjcm9sbCBvZmZzZXRzXG5mdW5jdGlvbiBmaW5kU2Nyb2xsQ29udGFpbmVycyhcblx0ZWxlbWVudDogSFRNTE9yU1ZHRWxlbWVudCB8IG51bGwsXG5cdHdpbmRvdzogV2luZG93IHwgbnVsbCxcblx0ZG9jdW1lbnRCb2R5OiBIVE1MRWxlbWVudCxcbik6IEhUTUxPclNWR0VsZW1lbnRbXSB7XG5cdGNvbnN0IHJlc3VsdDogSFRNTE9yU1ZHRWxlbWVudFtdID0gW107XG5cdGlmICghZWxlbWVudCB8fCAhd2luZG93IHx8IGVsZW1lbnQgPT09IGRvY3VtZW50Qm9keSkgcmV0dXJuIHJlc3VsdDtcblx0Y29uc3QgeyBvdmVyZmxvdywgb3ZlcmZsb3dYLCBvdmVyZmxvd1kgfSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKFxuXHRcdGVsZW1lbnQgYXMgSFRNTEVsZW1lbnQsXG5cdCk7XG5cdGlmIChcblx0XHRbb3ZlcmZsb3csIG92ZXJmbG93WCwgb3ZlcmZsb3dZXS5zb21lKFxuXHRcdFx0KHByb3ApID0+IHByb3AgPT09ICdhdXRvJyB8fCBwcm9wID09PSAnc2Nyb2xsJyxcblx0XHQpXG5cdClcblx0XHRyZXN1bHQucHVzaChlbGVtZW50KTtcblx0cmV0dXJuIFtcblx0XHQuLi5yZXN1bHQsXG5cdFx0Li4uZmluZFNjcm9sbENvbnRhaW5lcnMoXG5cdFx0XHQoZWxlbWVudCBhcyBIVE1MRWxlbWVudCkucGFyZW50RWxlbWVudCxcblx0XHRcdHdpbmRvdyxcblx0XHRcdGRvY3VtZW50Qm9keSxcblx0XHQpLFxuXHRdO1xufVxuXG4vLyBDaGVja3MgaWYgZWxlbWVudCBib3VuZGFyaWVzIGFyZSBlcXVhbFxuY29uc3Qga2V5czogKGtleW9mIE9taXQ8UmVzaXplUmVzdWx0LCAnZW50cmllcycgfCAnZHByJz4pW10gPSBbXG5cdCd4Jyxcblx0J3knLFxuXHQndG9wJyxcblx0J2JvdHRvbScsXG5cdCdsZWZ0Jyxcblx0J3JpZ2h0Jyxcblx0J3dpZHRoJyxcblx0J2hlaWdodCcsXG5dO1xuY29uc3QgYXJlQm91bmRzRXF1YWwgPSAoXG5cdGE6IE9taXQ8UmVzaXplUmVzdWx0LCAnZW50cmllcycgfCAnZHByJz4sXG5cdGI6IE9taXQ8UmVzaXplUmVzdWx0LCAnZW50cmllcycgfCAnZHByJz4sXG4pID0+IGtleXMuZXZlcnkoKGtleSkgPT4gYVtrZXldID09PSBiW2tleV0pO1xuIl19