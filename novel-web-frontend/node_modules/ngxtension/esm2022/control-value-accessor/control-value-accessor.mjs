import { Directive, Injector, Input, Output, booleanAttribute, inject, runInInjectionContext, signal, } from '@angular/core';
import { toObservable } from '@angular/core/rxjs-interop';
import { NgControl, NgModel } from '@angular/forms';
import { createInjectionToken } from 'ngxtension/create-injection-token';
import { rxEffect } from 'ngxtension/rx-effect';
import { skip } from 'rxjs';
import * as i0 from "@angular/core";
const noop = () => undefined;
export const [injectCvaCompareTo, provideCvaCompareTo] = createInjectionToken(() => Object.is);
export const [injectCvaDefaultValue, provideCvaDefaultValue] = createInjectionToken(() => null);
/**
 * Provides a {@link NgxControlValueAccessorCompareTo comparator} based on a property of `T`.
 *
 * @example
 * ```ts
 * interface User {
 * 	id: string;
 * 	name: string;
 * }
 *
 * provideCvaCompareToByProp<User>('id');
 * ```
 */
export const provideCvaCompareToByProp = (prop) => provideCvaCompareTo((a, b) => Object.is(a?.[prop], b?.[prop]), true);
/**
 * `NgxControlValueAccessor` is a directive to reduce boilerplate when building components, which implement the [ControlValueAccessor](https://angular.dev/api/forms/ControlValueAccessor) interface.
 *
 * ## Usage
 *
 * `NgxControlValueAccessor` implements the [ControlValueAccessor](https://angular.dev/api/forms/ControlValueAccessor) interface and exposes a _simpler_ api. Declare `NgxControlValueAccessor` in the `hostDirectives` section of your component and inject the instance in order to wire up your template:
 *
 * - `NgxControlValueAccessor.value` for syncing the value
 * - `NgxControlValueAccessor.disabled` for syncing the disabled state
 * - `NgxControlValueAccessor.markAsTouched` for marking the view as _touched_
 *
 * The value and disabled state are also available as signals:
 *
 * - `NgxControlValueAccessor.value$`
 * - `NgxControlValueAccessor.disabled$`
 *
 * ### Example
 *
 * In this example `NgxControlValueAccessor` is used to create a `CustomInput` component.
 *
 * ```ts
 * @Component({
 *   selector: 'custom-input',
 *   hostDirectives: [NgxControlValueAccessor],
 *   template: `
 *     <label>
 *       <b>Custom label</b>
 *       <input
 *         type="text"
 *         (input)="cva.value = $event.target.value"
 *         [value]="cva.value$()"
 *         [disabled]="cva.disabled$()"
 *         (blur)="cva.markAsTouched()"
 *       />
 *     </label>
 *   `,
 *   standalone: true,
 * })
 * export class CustomInput {
 *   protected cva = inject<NgxControlValueAccessor<string>>(
 *     NgxControlValueAccessor,
 *   );
 * }
 * ```
 *
 * With usage:
 *
 * ```html
 * <custom-input [formControl]="control" />
 * <custom-input [(ngModel)]="value" />
 * ```
 *
 * ## Non Primitive Values
 *
 * When your model is a non primitive datatype, you should provide a _comparator_. It is a pure function which tells `NgxControlValueAccessor`, whether two values are _semantically_ equal:
 *
 * ```ts
 * (a, b) => boolean;
 * ```
 *
 * ### Example
 *
 * In this example `NgxControlValueAccessor` is used to create a `User` select. A `User` is identified by its `id`.
 *
 * ```ts
 * interface User {
 *   id: string;
 *   name: string;
 * }
 *
 * const userComparator: NgxControlValueAccessorCompareTo<User> = (a, b) =>
 *   a?.id === b?.id;
 *
 * provideCvaCompareTo(userComparator, true);
 *
 * // or
 *
 * provideCvaCompareToByProp<User>('id');
 * ```
 *
 * Full example:
 *
 * ```ts
 * @Component({
 *   selector: 'user-select',
 *   standalone: true,
 *   hostDirectives: [NgxControlValueAccessor],
 *   providers: [provideCvaCompareToByProp<User>('id')],
 *   template: `
 *     <label>
 *       <b>Select a user:</b>
 *       <select
 *         [disabled]="cva.disabled$()"
 *         (blur)="cva.markAsTouched()"
 *         (change)="onChange($event)"
 *       >
 *         <option [selected]="cva.value === null">-- no user selected --</option>
 *         @for (user of users; track user.id) {
 *           <option [value]="user.id" [selected]="user.id === cva.value?.id">
 *             {{ user.name }}
 *           </option>
 *         }
 *       </select>
 *     </label>
 *   `,
 * })
 * export class UserSelect {
 *   protected cva = inject<NgxControlValueAccessor<User | null>>(
 *     NgxControlValueAccessor,
 *   );
 *
 *   protected onChange = (event: Event) =>
 *     (this.cva.value =
 *       this.users.find(({ id }) => event.target.value === id) ?? null);
 *
 *   @Input()
 *   users: User[] = [];
 * }
 * ```
 *
 * With usage:
 *
 * ```html
 * <user-select [formControl]="userControl" [options]="users" />
 * <user-select [(ngModel)]="user" [options]="users" />
 * ```
 *
 * ## Without `NgControl`
 *
 * Optionally you can expose `inputs` and `outputs` in the `hostDirectives` declaration
 * and use it without a `NgControl` directive.
 *
 * ```ts
 * hostDirectives: [
 *   {
 *     directive: NgxControlValueAccessor,
 *     inputs: ['value'],
 *     outputs: ['valueChange'],
 *   },
 * ];
 * ```
 *
 * ```html
 * <custom-input [(value)]="value" />
 * ```
 */
export class NgxControlValueAccessor {
    /** @ignore */
    constructor() {
        /** @ignore */
        this.injector = inject(Injector);
        /**
         * The `NgControl` instance on this host element. If present, this `NgxControlValueAccessor` instance will be its value accessor.
         *
         * @see {@link NgControl}
         * @see {@link NgControl.valueAccessor}
         */
        this.ngControl = inject(NgControl, {
            self: true,
            optional: true,
        });
        /** @ignore */
        this.initialValue = () => {
            if (this.ngControl != null)
                return this.ngControl.value;
            return injectCvaDefaultValue();
        };
        /** The value of this. If a control is present, it reflects it's value. */
        this.value$ = signal(this.initialValue(), {
            equal: (a, b) => this.compareTo(a, b),
        });
        /** Whether this is disabled. If a control is present, it reflects it's disabled state. */
        this.disabled$ = signal(this.ngControl?.disabled ?? false);
        /**
         * A comparator, which determines value changes. Should return true, if two values are considered semanticly equal.
         *
         * Defaults to {@link Object.is} in order to align with change detection behavior for inputs.
         */
        this.compareTo$ = signal(injectCvaCompareTo());
        /**
         * Emits whenever this {@link NgxControlValueAccessor.value$ value} changes.
         */
        this.valueChange = toObservable(this.value$).pipe(skip(1)); // -> hot observable
        /**
         * This function should be called when this host is considered `touched`.
         *
         * NOTE: Whenever a `blur` event is triggered on this host, this function is called.
         *
         * @see {@link NgxControlValueAccessor.registerOnTouched}
         * @see {@link NgxControlValueAccessor.ngControl}
         */
        this.markAsTouched = () => this.onTouched();
        /** This function is set by the forms api, if a control is present. */
        this.onChange = noop;
        /** This function is set by the forms api, if a control is present. */
        this.onTouched = noop;
        // control value accessor implementation
        this.writeValue = (value) => {
            if (this.registered)
                this.value = value;
        };
        this.registerOnChange = (onChange) => (this.onChange = onChange);
        this.registerOnTouched = (onTouched) => (this.onTouched = onTouched);
        this.setDisabledState = (disabled) => {
            if (this.registered)
                this.disabled$.set(disabled);
        };
        if (this.ngControl != null)
            this.ngControl.valueAccessor = this;
    }
    /** @ignore */
    ngOnInit() {
        if (this.ngControl != null) {
            runInInjectionContext(this.injector, () => {
                // NOTE: Don't use 'effect' because we have no idea if we are setting other signals here.
                // sync value
                rxEffect(toObservable(this.value$), (value) => {
                    if (!this.compareTo(this.ngControl?.value, value))
                        this.onChange(value);
                });
                // sync disabled state
                rxEffect(toObservable(this.disabled$), (disabled) => {
                    if (this.ngControl != null &&
                        this.ngControl.control != null &&
                        this.ngControl.disabled !== disabled)
                        this.ngControl.control[disabled ? 'disable' : 'enable']();
                });
            });
        }
    }
    /** The value of this. If a control is present, it reflects it's value. */
    set value(value) {
        this.value$.set(value);
    }
    get value() {
        return this.value$();
    }
    /** Whether this is disabled. If a control is present, it reflects it's disabled state. */
    set disabled(disabled) {
        this.disabled$.set(disabled);
    }
    get disabled() {
        return this.disabled$();
    }
    /**
     * A comparator, which determines value changes. Should return true, if two values are considered semanticly equal.
     *
     * Defaults to {@link Object.is} in order to align with change detection behavior for inputs.
     */
    set compareTo(compareTo) {
        if (typeof compareTo === 'function')
            this.compareTo$.set(compareTo);
    }
    get compareTo() {
        return this.compareTo$();
    }
    /**
     * `NgModel` sets up the control in `ngOnChanges`. Idk if bug or on purpose, but `writeValue` and `setDisabledState` are called before the inputs are set.
     * {@link https://github.com/angular/angular/blob/main/packages/forms/src/directives/ng_model.ts#L223}
     *
     * @ignore
     */
    get registered() {
        return this.ngControl instanceof NgModel
            ? this.ngControl._registered
            : true;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.7", ngImport: i0, type: NgxControlValueAccessor, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "16.1.0", version: "18.2.7", type: NgxControlValueAccessor, isStandalone: true, inputs: { value: "value", disabled: ["disabled", "disabled", booleanAttribute], compareTo: "compareTo" }, outputs: { valueChange: "valueChange" }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.7", ngImport: i0, type: NgxControlValueAccessor, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                }]
        }], ctorParameters: () => [], propDecorators: { value: [{
                type: Input
            }], disabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], compareTo: [{
                type: Input
            }], valueChange: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udHJvbC12YWx1ZS1hY2Nlc3Nvci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL2xpYnMvbmd4dGVuc2lvbi9jb250cm9sLXZhbHVlLWFjY2Vzc29yL3NyYy9jb250cm9sLXZhbHVlLWFjY2Vzc29yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTixTQUFTLEVBQ1QsUUFBUSxFQUNSLEtBQUssRUFDTCxNQUFNLEVBQ04sZ0JBQWdCLEVBQ2hCLE1BQU0sRUFDTixxQkFBcUIsRUFDckIsTUFBTSxHQUVOLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQUMxRCxPQUFPLEVBQUUsU0FBUyxFQUFFLE9BQU8sRUFBNkIsTUFBTSxnQkFBZ0IsQ0FBQztBQUMvRSxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxtQ0FBbUMsQ0FBQztBQUN6RSxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDaEQsT0FBTyxFQUFFLElBQUksRUFBRSxNQUFNLE1BQU0sQ0FBQzs7QUFFNUIsTUFBTSxJQUFJLEdBQUcsR0FBRyxFQUFFLENBQUMsU0FBUyxDQUFDO0FBUTdCLE1BQU0sQ0FBQyxNQUFNLENBQUMsa0JBQWtCLEVBQUUsbUJBQW1CLENBQUMsR0FBRyxvQkFBb0IsQ0FFM0UsR0FBRyxFQUFFLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBRW5CLE1BQU0sQ0FBQyxNQUFNLENBQUMscUJBQXFCLEVBQUUsc0JBQXNCLENBQUMsR0FDM0Qsb0JBQW9CLENBQVksR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7QUFFN0M7Ozs7Ozs7Ozs7OztHQVlHO0FBQ0gsTUFBTSxDQUFDLE1BQU0seUJBQXlCLEdBQUcsQ0FBSSxJQUFhLEVBQUUsRUFBRSxDQUM3RCxtQkFBbUIsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFB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RUQsSUFBVyxRQUFRO1FBQ2xCLE9BQU8sSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDO0lBQ3pCLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsSUFDVyxTQUFTLENBQUMsU0FBUztRQUM3QixJQUFJLE9BQU8sU0FBUyxLQUFLLFVBQVU7WUFBRSxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUNyRSxDQUFDO0lBRUQsSUFBVyxTQUFTO1FBQ25CLE9BQU8sSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO0lBQzFCLENBQUM7SUF3QkQ7Ozs7O09BS0c7SUFDSCxJQUFZLFVBQVU7UUFDckIsT0FBTyxJQUFJLENBQUMsU0FBUyxZQUFZLE9BQU87WUFDdkMsQ0FBQyxDQUFFLElBQUksQ0FBQyxTQUFpRCxDQUFDLFdBQVc7WUFDckUsQ0FBQyxDQUFDLElBQUksQ0FBQztJQUNULENBQUM7OEdBdklXLHVCQUF1QjtrR0FBdkIsdUJBQXVCLG1GQWdGZixnQkFBZ0I7OzJGQWhGeEIsdUJBQXVCO2tCQUhuQyxTQUFTO21CQUFDO29CQUNWLFVBQVUsRUFBRSxJQUFJO2lCQUNoQjt3REF3RVcsS0FBSztzQkFEZixLQUFLO2dCQVdLLFFBQVE7c0JBRGxCLEtBQUs7dUJBQUMsRUFBRSxTQUFTLEVBQUUsZ0JBQWdCLEVBQUU7Z0JBZTNCLFNBQVM7c0JBRG5CLEtBQUs7Z0JBYVUsV0FBVztzQkFEMUIsTUFBTSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG5cdERpcmVjdGl2ZSxcblx0SW5qZWN0b3IsXG5cdElucHV0LFxuXHRPdXRwdXQsXG5cdGJvb2xlYW5BdHRyaWJ1dGUsXG5cdGluamVjdCxcblx0cnVuSW5JbmplY3Rpb25Db250ZXh0LFxuXHRzaWduYWwsXG5cdHR5cGUgT25Jbml0LFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IHRvT2JzZXJ2YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUvcnhqcy1pbnRlcm9wJztcbmltcG9ydCB7IE5nQ29udHJvbCwgTmdNb2RlbCwgdHlwZSBDb250cm9sVmFsdWVBY2Nlc3NvciB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IGNyZWF0ZUluamVjdGlvblRva2VuIH0gZnJvbSAnbmd4dGVuc2lvbi9jcmVhdGUtaW5qZWN0aW9uLXRva2VuJztcbmltcG9ydCB7IHJ4RWZmZWN0IH0gZnJvbSAnbmd4dGVuc2lvbi9yeC1lZmZlY3QnO1xuaW1wb3J0IHsgc2tpcCB9IGZyb20gJ3J4anMnO1xuXG5jb25zdCBub29wID0gKCkgPT4gdW5kZWZpbmVkO1xuXG4vKiogQHNlZSB7QGxpbmsgTmd4Q29udHJvbFZhbHVlQWNjZXNzb3IuY29tcGFyZVRvfS4gKi9cbmV4cG9ydCB0eXBlIE5neENvbnRyb2xWYWx1ZUFjY2Vzc29yQ29tcGFyZVRvPFQgPSBhbnk+ID0gKFxuXHRhPzogVCxcblx0Yj86IFQsXG4pID0+IGJvb2xlYW47XG5cbmV4cG9ydCBjb25zdCBbaW5qZWN0Q3ZhQ29tcGFyZVRvLCBwcm92aWRlQ3ZhQ29tcGFyZVRvXSA9IGNyZWF0ZUluamVjdGlvblRva2VuPFxuXHQoKSA9PiBOZ3hDb250cm9sVmFsdWVBY2Nlc3NvckNvbXBhcmVUb1xuPigoKSA9PiBPYmplY3QuaXMpO1xuXG5leHBvcnQgY29uc3QgW2luamVjdEN2YURlZmF1bHRWYWx1ZSwgcHJvdmlkZUN2YURlZmF1bHRWYWx1ZV0gPVxuXHRjcmVhdGVJbmplY3Rpb25Ub2tlbjwoKSA9PiBhbnk+KCgpID0+IG51bGwpO1xuXG4vKipcbiAqIFByb3ZpZGVzIGEge0BsaW5rIE5neENvbnRyb2xWYWx1ZUFjY2Vzc29yQ29tcGFyZVRvIGNvbXBhcmF0b3J9IGJhc2VkIG9uIGEgcHJvcGVydHkgb2YgYFRgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW50ZXJmYWNlIFVzZXIge1xuICogXHRpZDogc3RyaW5nO1xuICogXHRuYW1lOiBzdHJpbmc7XG4gKiB9XG4gKlxuICogcHJvdmlkZUN2YUNvbXBhcmVUb0J5UHJvcDxVc2VyPignaWQnKTtcbiAqIGBgYFxuICovXG5leHBvcnQgY29uc3QgcHJvdmlkZUN2YUNvbXBhcmVUb0J5UHJvcCA9IDxUPihwcm9wOiBrZXlvZiBUKSA9PlxuXHRwcm92aWRlQ3ZhQ29tcGFyZVRvKChhLCBiKSA9PiBPYmplY3QuaXMoYT8uW3Byb3BdLCBiPy5bcHJvcF0pLCB0cnVlKTtcblxuLyoqXG4gKiBgTmd4Q29udHJvbFZhbHVlQWNjZXNzb3JgIGlzIGEgZGlyZWN0aXZlIHRvIHJlZHVjZSBib2lsZXJwbGF0ZSB3aGVuIGJ1aWxkaW5nIGNvbXBvbmVudHMsIHdoaWNoIGltcGxlbWVudCB0aGUgW0NvbnRyb2xWYWx1ZUFjY2Vzc29yXShodHRwczovL2FuZ3VsYXIuZGV2L2FwaS9mb3Jtcy9Db250cm9sVmFsdWVBY2Nlc3NvcikgaW50ZXJmYWNlLlxuICpcbiAqICMjIFVzYWdlXG4gKlxuICogYE5neENvbnRyb2xWYWx1ZUFjY2Vzc29yYCBpbXBsZW1lbnRzIHRoZSBbQ29udHJvbFZhbHVlQWNjZXNzb3JdKGh0dHBzOi8vYW5ndWxhci5kZXYvYXBpL2Zvcm1zL0NvbnRyb2xWYWx1ZUFjY2Vzc29yKSBpbnRlcmZhY2UgYW5kIGV4cG9zZXMgYSBfc2ltcGxlcl8gYXBpLiBEZWNsYXJlIGBOZ3hDb250cm9sVmFsdWVBY2Nlc3NvcmAgaW4gdGhlIGBob3N0RGlyZWN0aXZlc2Agc2VjdGlvbiBvZiB5b3VyIGNvbXBvbmVudCBhbmQgaW5qZWN0IHRoZSBpbnN0YW5jZSBpbiBvcmRlciB0byB3aXJlIHVwIHlvdXIgdGVtcGxhdGU6XG4gKlxuICogLSBgTmd4Q29udHJvbFZhbHVlQWNjZXNzb3IudmFsdWVgIGZvciBzeW5jaW5nIHRoZSB2YWx1ZVxuICogLSBgTmd4Q29udHJvbFZhbHVlQWNjZXNzb3IuZGlzYWJsZWRgIGZvciBzeW5jaW5nIHRoZSBkaXNhYmxlZCBzdGF0ZVxuICogLSBgTmd4Q29udHJvbFZhbHVlQWNjZXNzb3IubWFya0FzVG91Y2hlZGAgZm9yIG1hcmtpbmcgdGhlIHZpZXcgYXMgX3RvdWNoZWRfXG4gKlxuICogVGhlIHZhbHVlIGFuZCBkaXNhYmxlZCBzdGF0ZSBhcmUgYWxzbyBhdmFpbGFibGUgYXMgc2lnbmFsczpcbiAqXG4gKiAtIGBOZ3hDb250cm9sVmFsdWVBY2Nlc3Nvci52YWx1ZSRgXG4gKiAtIGBOZ3hDb250cm9sVmFsdWVBY2Nlc3Nvci5kaXNhYmxlZCRgXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqXG4gKiBJbiB0aGlzIGV4YW1wbGUgYE5neENvbnRyb2xWYWx1ZUFjY2Vzc29yYCBpcyB1c2VkIHRvIGNyZWF0ZSBhIGBDdXN0b21JbnB1dGAgY29tcG9uZW50LlxuICpcbiAqIGBgYHRzXG4gKiBAQ29tcG9uZW50KHtcbiAqICAgc2VsZWN0b3I6ICdjdXN0b20taW5wdXQnLFxuICogICBob3N0RGlyZWN0aXZlczogW05neENvbnRyb2xWYWx1ZUFjY2Vzc29yXSxcbiAqICAgdGVtcGxhdGU6IGBcbiAqICAgICA8bGFiZWw+XG4gKiAgICAgICA8Yj5DdXN0b20gbGFiZWw8L2I+XG4gKiAgICAgICA8aW5wdXRcbiAqICAgICAgICAgdHlwZT1cInRleHRcIlxuICogICAgICAgICAoaW5wdXQpPVwiY3ZhLnZhbHVlID0gJGV2ZW50LnRhcmdldC52YWx1ZVwiXG4gKiAgICAgICAgIFt2YWx1ZV09XCJjdmEudmFsdWUkKClcIlxuICogICAgICAgICBbZGlzYWJsZWRdPVwiY3ZhLmRpc2FibGVkJCgpXCJcbiAqICAgICAgICAgKGJsdXIpPVwiY3ZhLm1hcmtBc1RvdWNoZWQoKVwiXG4gKiAgICAgICAvPlxuICogICAgIDwvbGFiZWw+XG4gKiAgIGAsXG4gKiAgIHN0YW5kYWxvbmU6IHRydWUsXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEN1c3RvbUlucHV0IHtcbiAqICAgcHJvdGVjdGVkIGN2YSA9IGluamVjdDxOZ3hDb250cm9sVmFsdWVBY2Nlc3NvcjxzdHJpbmc+PihcbiAqICAgICBOZ3hDb250cm9sVmFsdWVBY2Nlc3NvcixcbiAqICAgKTtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIFdpdGggdXNhZ2U6XG4gKlxuICogYGBgaHRtbFxuICogPGN1c3RvbS1pbnB1dCBbZm9ybUNvbnRyb2xdPVwiY29udHJvbFwiIC8+XG4gKiA8Y3VzdG9tLWlucHV0IFsobmdNb2RlbCldPVwidmFsdWVcIiAvPlxuICogYGBgXG4gKlxuICogIyMgTm9uIFByaW1pdGl2ZSBWYWx1ZXNcbiAqXG4gKiBXaGVuIHlvdXIgbW9kZWwgaXMgYSBub24gcHJpbWl0aXZlIGRhdGF0eXBlLCB5b3Ugc2hvdWxkIHByb3ZpZGUgYSBfY29tcGFyYXRvcl8uIEl0IGlzIGEgcHVyZSBmdW5jdGlvbiB3aGljaCB0ZWxscyBgTmd4Q29udHJvbFZhbHVlQWNjZXNzb3JgLCB3aGV0aGVyIHR3byB2YWx1ZXMgYXJlIF9zZW1hbnRpY2FsbHlfIGVxdWFsOlxuICpcbiAqIGBgYHRzXG4gKiAoYSwgYikgPT4gYm9vbGVhbjtcbiAqIGBgYFxuICpcbiAqICMjIyBFeGFtcGxlXG4gKlxuICogSW4gdGhpcyBleGFtcGxlIGBOZ3hDb250cm9sVmFsdWVBY2Nlc3NvcmAgaXMgdXNlZCB0byBjcmVhdGUgYSBgVXNlcmAgc2VsZWN0LiBBIGBVc2VyYCBpcyBpZGVudGlmaWVkIGJ5IGl0cyBgaWRgLlxuICpcbiAqIGBgYHRzXG4gKiBpbnRlcmZhY2UgVXNlciB7XG4gKiAgIGlkOiBzdHJpbmc7XG4gKiAgIG5hbWU6IHN0cmluZztcbiAqIH1cbiAqXG4gKiBjb25zdCB1c2VyQ29tcGFyYXRvcjogTmd4Q29udHJvbFZhbHVlQWNjZXNzb3JDb21wYXJlVG88VXNlcj4gPSAoYSwgYikgPT5cbiAqICAgYT8uaWQgPT09IGI/LmlkO1xuICpcbiAqIHByb3ZpZGVDdmFDb21wYXJlVG8odXNlckNvbXBhcmF0b3IsIHRydWUpO1xuICpcbiAqIC8vIG9yXG4gKlxuICogcHJvdmlkZUN2YUNvbXBhcmVUb0J5UHJvcDxVc2VyPignaWQnKTtcbiAqIGBgYFxuICpcbiAqIEZ1bGwgZXhhbXBsZTpcbiAqXG4gKiBgYGB0c1xuICogQENvbXBvbmVudCh7XG4gKiAgIHNlbGVjdG9yOiAndXNlci1zZWxlY3QnLFxuICogICBzdGFuZGFsb25lOiB0cnVlLFxuICogICBob3N0RGlyZWN0aXZlczogW05neENvbnRyb2xWYWx1ZUFjY2Vzc29yXSxcbiAqICAgcHJvdmlkZXJzOiBbcHJvdmlkZUN2YUNvbXBhcmVUb0J5UHJvcDxVc2VyPignaWQnKV0sXG4gKiAgIHRlbXBsYXRlOiBgXG4gKiAgICAgPGxhYmVsPlxuICogICAgICAgPGI+U2VsZWN0IGEgdXNlcjo8L2I+XG4gKiAgICAgICA8c2VsZWN0XG4gKiAgICAgICAgIFtkaXNhYmxlZF09XCJjdmEuZGlzYWJsZWQkKClcIlxuICogICAgICAgICAoYmx1cik9XCJjdmEubWFya0FzVG91Y2hlZCgpXCJcbiAqICAgICAgICAgKGNoYW5nZSk9XCJvbkNoYW5nZSgkZXZlbnQpXCJcbiAqICAgICAgID5cbiAqICAgICAgICAgPG9wdGlvbiBbc2VsZWN0ZWRdPVwiY3ZhLnZhbHVlID09PSBudWxsXCI+LS0gbm8gdXNlciBzZWxlY3RlZCAtLTwvb3B0aW9uPlxuICogICAgICAgICBAZm9yICh1c2VyIG9mIHVzZXJzOyB0cmFjayB1c2VyLmlkKSB7XG4gKiAgICAgICAgICAgPG9wdGlvbiBbdmFsdWVdPVwidXNlci5pZFwiIFtzZWxlY3RlZF09XCJ1c2VyLmlkID09PSBjdmEudmFsdWU/LmlkXCI+XG4gKiAgICAgICAgICAgICB7eyB1c2VyLm5hbWUgfX1cbiAqICAgICAgICAgICA8L29wdGlvbj5cbiAqICAgICAgICAgfVxuICogICAgICAgPC9zZWxlY3Q+XG4gKiAgICAgPC9sYWJlbD5cbiAqICAgYCxcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgVXNlclNlbGVjdCB7XG4gKiAgIHByb3RlY3RlZCBjdmEgPSBpbmplY3Q8Tmd4Q29udHJvbFZhbHVlQWNjZXNzb3I8VXNlciB8IG51bGw+PihcbiAqICAgICBOZ3hDb250cm9sVmFsdWVBY2Nlc3NvcixcbiAqICAgKTtcbiAqXG4gKiAgIHByb3RlY3RlZCBvbkNoYW5nZSA9IChldmVudDogRXZlbnQpID0+XG4gKiAgICAgKHRoaXMuY3ZhLnZhbHVlID1cbiAqICAgICAgIHRoaXMudXNlcnMuZmluZCgoeyBpZCB9KSA9PiBldmVudC50YXJnZXQudmFsdWUgPT09IGlkKSA/PyBudWxsKTtcbiAqXG4gKiAgIEBJbnB1dCgpXG4gKiAgIHVzZXJzOiBVc2VyW10gPSBbXTtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIFdpdGggdXNhZ2U6XG4gKlxuICogYGBgaHRtbFxuICogPHVzZXItc2VsZWN0IFtmb3JtQ29udHJvbF09XCJ1c2VyQ29udHJvbFwiIFtvcHRpb25zXT1cInVzZXJzXCIgLz5cbiAqIDx1c2VyLXNlbGVjdCBbKG5nTW9kZWwpXT1cInVzZXJcIiBbb3B0aW9uc109XCJ1c2Vyc1wiIC8+XG4gKiBgYGBcbiAqXG4gKiAjIyBXaXRob3V0IGBOZ0NvbnRyb2xgXG4gKlxuICogT3B0aW9uYWxseSB5b3UgY2FuIGV4cG9zZSBgaW5wdXRzYCBhbmQgYG91dHB1dHNgIGluIHRoZSBgaG9zdERpcmVjdGl2ZXNgIGRlY2xhcmF0aW9uXG4gKiBhbmQgdXNlIGl0IHdpdGhvdXQgYSBgTmdDb250cm9sYCBkaXJlY3RpdmUuXG4gKlxuICogYGBgdHNcbiAqIGhvc3REaXJlY3RpdmVzOiBbXG4gKiAgIHtcbiAqICAgICBkaXJlY3RpdmU6IE5neENvbnRyb2xWYWx1ZUFjY2Vzc29yLFxuICogICAgIGlucHV0czogWyd2YWx1ZSddLFxuICogICAgIG91dHB1dHM6IFsndmFsdWVDaGFuZ2UnXSxcbiAqICAgfSxcbiAqIF07XG4gKiBgYGBcbiAqXG4gKiBgYGBodG1sXG4gKiA8Y3VzdG9tLWlucHV0IFsodmFsdWUpXT1cInZhbHVlXCIgLz5cbiAqIGBgYFxuICovXG5ARGlyZWN0aXZlKHtcblx0c3RhbmRhbG9uZTogdHJ1ZSxcbn0pXG5leHBvcnQgY2xhc3MgTmd4Q29udHJvbFZhbHVlQWNjZXNzb3I8VCA9IGFueT5cblx0aW1wbGVtZW50cyBDb250cm9sVmFsdWVBY2Nlc3NvciwgT25Jbml0XG57XG5cdC8qKiBAaWdub3JlICovXG5cdHByaXZhdGUgcmVhZG9ubHkgaW5qZWN0b3IgPSBpbmplY3QoSW5qZWN0b3IpO1xuXG5cdC8qKlxuXHQgKiBUaGUgYE5nQ29udHJvbGAgaW5zdGFuY2Ugb24gdGhpcyBob3N0IGVsZW1lbnQuIElmIHByZXNlbnQsIHRoaXMgYE5neENvbnRyb2xWYWx1ZUFjY2Vzc29yYCBpbnN0YW5jZSB3aWxsIGJlIGl0cyB2YWx1ZSBhY2Nlc3Nvci5cblx0ICpcblx0ICogQHNlZSB7QGxpbmsgTmdDb250cm9sfVxuXHQgKiBAc2VlIHtAbGluayBOZ0NvbnRyb2wudmFsdWVBY2Nlc3Nvcn1cblx0ICovXG5cdHB1YmxpYyByZWFkb25seSBuZ0NvbnRyb2wgPSBpbmplY3QoTmdDb250cm9sLCB7XG5cdFx0c2VsZjogdHJ1ZSxcblx0XHRvcHRpb25hbDogdHJ1ZSxcblx0fSk7XG5cblx0LyoqIEBpZ25vcmUgKi9cblx0cHVibGljIGNvbnN0cnVjdG9yKCkge1xuXHRcdGlmICh0aGlzLm5nQ29udHJvbCAhPSBudWxsKSB0aGlzLm5nQ29udHJvbC52YWx1ZUFjY2Vzc29yID0gdGhpcztcblx0fVxuXG5cdC8qKiBAaWdub3JlICovXG5cdHByaXZhdGUgaW5pdGlhbFZhbHVlID0gKCk6IFQgPT4ge1xuXHRcdGlmICh0aGlzLm5nQ29udHJvbCAhPSBudWxsKSByZXR1cm4gdGhpcy5uZ0NvbnRyb2wudmFsdWU7XG5cdFx0cmV0dXJuIGluamVjdEN2YURlZmF1bHRWYWx1ZSgpO1xuXHR9O1xuXG5cdC8qKiBUaGUgdmFsdWUgb2YgdGhpcy4gSWYgYSBjb250cm9sIGlzIHByZXNlbnQsIGl0IHJlZmxlY3RzIGl0J3MgdmFsdWUuICovXG5cdHB1YmxpYyByZWFkb25seSB2YWx1ZSQgPSBzaWduYWwodGhpcy5pbml0aWFsVmFsdWUoKSwge1xuXHRcdGVxdWFsOiAoYSwgYikgPT4gdGhpcy5jb21wYXJlVG8oYSwgYiksXG5cdH0pO1xuXG5cdC8qKiBXaGV0aGVyIHRoaXMgaXMgZGlzYWJsZWQuIElmIGEgY29udHJvbCBpcyBwcmVzZW50LCBpdCByZWZsZWN0cyBpdCdzIGRpc2FibGVkIHN0YXRlLiAqL1xuXHRwdWJsaWMgcmVhZG9ubHkgZGlzYWJsZWQkID0gc2lnbmFsKHRoaXMubmdDb250cm9sPy5kaXNhYmxlZCA/PyBmYWxzZSk7XG5cblx0LyoqXG5cdCAqIEEgY29tcGFyYXRvciwgd2hpY2ggZGV0ZXJtaW5lcyB2YWx1ZSBjaGFuZ2VzLiBTaG91bGQgcmV0dXJuIHRydWUsIGlmIHR3byB2YWx1ZXMgYXJlIGNvbnNpZGVyZWQgc2VtYW50aWNseSBlcXVhbC5cblx0ICpcblx0ICogRGVmYXVsdHMgdG8ge0BsaW5rIE9iamVjdC5pc30gaW4gb3JkZXIgdG8gYWxpZ24gd2l0aCBjaGFuZ2UgZGV0ZWN0aW9uIGJlaGF2aW9yIGZvciBpbnB1dHMuXG5cdCAqL1xuXHRwdWJsaWMgcmVhZG9ubHkgY29tcGFyZVRvJCA9XG5cdFx0c2lnbmFsPE5neENvbnRyb2xWYWx1ZUFjY2Vzc29yQ29tcGFyZVRvPFQ+PihpbmplY3RDdmFDb21wYXJlVG8oKSk7XG5cblx0LyoqIEBpZ25vcmUgKi9cblx0cHVibGljIG5nT25Jbml0KCk6IHZvaWQge1xuXHRcdGlmICh0aGlzLm5nQ29udHJvbCAhPSBudWxsKSB7XG5cdFx0XHRydW5JbkluamVjdGlvbkNvbnRleHQodGhpcy5pbmplY3RvciwgKCkgPT4ge1xuXHRcdFx0XHQvLyBOT1RFOiBEb24ndCB1c2UgJ2VmZmVjdCcgYmVjYXVzZSB3ZSBoYXZlIG5vIGlkZWEgaWYgd2UgYXJlIHNldHRpbmcgb3RoZXIgc2lnbmFscyBoZXJlLlxuXG5cdFx0XHRcdC8vIHN5bmMgdmFsdWVcblx0XHRcdFx0cnhFZmZlY3QodG9PYnNlcnZhYmxlKHRoaXMudmFsdWUkKSwgKHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0aWYgKCF0aGlzLmNvbXBhcmVUbyh0aGlzLm5nQ29udHJvbD8udmFsdWUsIHZhbHVlKSlcblx0XHRcdFx0XHRcdHRoaXMub25DaGFuZ2UodmFsdWUpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHQvLyBzeW5jIGRpc2FibGVkIHN0YXRlXG5cdFx0XHRcdHJ4RWZmZWN0KHRvT2JzZXJ2YWJsZSh0aGlzLmRpc2FibGVkJCksIChkaXNhYmxlZCkgPT4ge1xuXHRcdFx0XHRcdGlmIChcblx0XHRcdFx0XHRcdHRoaXMubmdDb250cm9sICE9IG51bGwgJiZcblx0XHRcdFx0XHRcdHRoaXMubmdDb250cm9sLmNvbnRyb2wgIT0gbnVsbCAmJlxuXHRcdFx0XHRcdFx0dGhpcy5uZ0NvbnRyb2wuZGlzYWJsZWQgIT09IGRpc2FibGVkXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0dGhpcy5uZ0NvbnRyb2wuY29udHJvbFtkaXNhYmxlZCA/ICdkaXNhYmxlJyA6ICdlbmFibGUnXSgpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdC8qKiBUaGUgdmFsdWUgb2YgdGhpcy4gSWYgYSBjb250cm9sIGlzIHByZXNlbnQsIGl0IHJlZmxlY3RzIGl0J3MgdmFsdWUuICovXG5cdEBJbnB1dCgpXG5cdHB1YmxpYyBzZXQgdmFsdWUodmFsdWU6IFQpIHtcblx0XHR0aGlzLnZhbHVlJC5zZXQodmFsdWUpO1xuXHR9XG5cblx0cHVibGljIGdldCB2YWx1ZSgpIHtcblx0XHRyZXR1cm4gdGhpcy52YWx1ZSQoKTtcblx0fVxuXG5cdC8qKiBXaGV0aGVyIHRoaXMgaXMgZGlzYWJsZWQuIElmIGEgY29udHJvbCBpcyBwcmVzZW50LCBpdCByZWZsZWN0cyBpdCdzIGRpc2FibGVkIHN0YXRlLiAqL1xuXHRASW5wdXQoeyB0cmFuc2Zvcm06IGJvb2xlYW5BdHRyaWJ1dGUgfSlcblx0cHVibGljIHNldCBkaXNhYmxlZChkaXNhYmxlZDogYm9vbGVhbikge1xuXHRcdHRoaXMuZGlzYWJsZWQkLnNldChkaXNhYmxlZCk7XG5cdH1cblxuXHRwdWJsaWMgZ2V0IGRpc2FibGVkKCkge1xuXHRcdHJldHVybiB0aGlzLmRpc2FibGVkJCgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgY29tcGFyYXRvciwgd2hpY2ggZGV0ZXJtaW5lcyB2YWx1ZSBjaGFuZ2VzLiBTaG91bGQgcmV0dXJuIHRydWUsIGlmIHR3byB2YWx1ZXMgYXJlIGNvbnNpZGVyZWQgc2VtYW50aWNseSBlcXVhbC5cblx0ICpcblx0ICogRGVmYXVsdHMgdG8ge0BsaW5rIE9iamVjdC5pc30gaW4gb3JkZXIgdG8gYWxpZ24gd2l0aCBjaGFuZ2UgZGV0ZWN0aW9uIGJlaGF2aW9yIGZvciBpbnB1dHMuXG5cdCAqL1xuXHRASW5wdXQoKVxuXHRwdWJsaWMgc2V0IGNvbXBhcmVUbyhjb21wYXJlVG8pIHtcblx0XHRpZiAodHlwZW9mIGNvbXBhcmVUbyA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5jb21wYXJlVG8kLnNldChjb21wYXJlVG8pO1xuXHR9XG5cblx0cHVibGljIGdldCBjb21wYXJlVG8oKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29tcGFyZVRvJCgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEVtaXRzIHdoZW5ldmVyIHRoaXMge0BsaW5rIE5neENvbnRyb2xWYWx1ZUFjY2Vzc29yLnZhbHVlJCB2YWx1ZX0gY2hhbmdlcy5cblx0ICovXG5cdEBPdXRwdXQoKVxuXHRwdWJsaWMgcmVhZG9ubHkgdmFsdWVDaGFuZ2UgPSB0b09ic2VydmFibGUodGhpcy52YWx1ZSQpLnBpcGUoc2tpcCgxKSk7IC8vIC0+IGhvdCBvYnNlcnZhYmxlXG5cblx0LyoqXG5cdCAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIGNhbGxlZCB3aGVuIHRoaXMgaG9zdCBpcyBjb25zaWRlcmVkIGB0b3VjaGVkYC5cblx0ICpcblx0ICogTk9URTogV2hlbmV2ZXIgYSBgYmx1cmAgZXZlbnQgaXMgdHJpZ2dlcmVkIG9uIHRoaXMgaG9zdCwgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQuXG5cdCAqXG5cdCAqIEBzZWUge0BsaW5rIE5neENvbnRyb2xWYWx1ZUFjY2Vzc29yLnJlZ2lzdGVyT25Ub3VjaGVkfVxuXHQgKiBAc2VlIHtAbGluayBOZ3hDb250cm9sVmFsdWVBY2Nlc3Nvci5uZ0NvbnRyb2x9XG5cdCAqL1xuXHRwdWJsaWMgbWFya0FzVG91Y2hlZCA9ICgpID0+IHRoaXMub25Ub3VjaGVkKCk7XG5cblx0LyoqIFRoaXMgZnVuY3Rpb24gaXMgc2V0IGJ5IHRoZSBmb3JtcyBhcGksIGlmIGEgY29udHJvbCBpcyBwcmVzZW50LiAqL1xuXHRwcml2YXRlIG9uQ2hhbmdlOiAodmFsdWU6IFQpID0+IHZvaWQgPSBub29wO1xuXG5cdC8qKiBUaGlzIGZ1bmN0aW9uIGlzIHNldCBieSB0aGUgZm9ybXMgYXBpLCBpZiBhIGNvbnRyb2wgaXMgcHJlc2VudC4gKi9cblx0cHJpdmF0ZSBvblRvdWNoZWQ6ICgpID0+IHZvaWQgPSBub29wO1xuXG5cdC8qKlxuXHQgKiBgTmdNb2RlbGAgc2V0cyB1cCB0aGUgY29udHJvbCBpbiBgbmdPbkNoYW5nZXNgLiBJZGsgaWYgYnVnIG9yIG9uIHB1cnBvc2UsIGJ1dCBgd3JpdGVWYWx1ZWAgYW5kIGBzZXREaXNhYmxlZFN0YXRlYCBhcmUgY2FsbGVkIGJlZm9yZSB0aGUgaW5wdXRzIGFyZSBzZXQuXG5cdCAqIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2Jsb2IvbWFpbi9wYWNrYWdlcy9mb3Jtcy9zcmMvZGlyZWN0aXZlcy9uZ19tb2RlbC50cyNMMjIzfVxuXHQgKlxuXHQgKiBAaWdub3JlXG5cdCAqL1xuXHRwcml2YXRlIGdldCByZWdpc3RlcmVkKCkge1xuXHRcdHJldHVybiB0aGlzLm5nQ29udHJvbCBpbnN0YW5jZW9mIE5nTW9kZWxcblx0XHRcdD8gKHRoaXMubmdDb250cm9sIGFzIHVua25vd24gYXMgeyBfcmVnaXN0ZXJlZDogYm9vbGVhbiB9KS5fcmVnaXN0ZXJlZFxuXHRcdFx0OiB0cnVlO1xuXHR9XG5cblx0Ly8gY29udHJvbCB2YWx1ZSBhY2Nlc3NvciBpbXBsZW1lbnRhdGlvblxuXG5cdHB1YmxpYyB3cml0ZVZhbHVlID0gKHZhbHVlOiBUKSA9PiB7XG5cdFx0aWYgKHRoaXMucmVnaXN0ZXJlZCkgdGhpcy52YWx1ZSA9IHZhbHVlO1xuXHR9O1xuXG5cdHB1YmxpYyByZWdpc3Rlck9uQ2hhbmdlID0gKG9uQ2hhbmdlOiAodmFsdWU6IFQpID0+IHZvaWQpID0+XG5cdFx0KHRoaXMub25DaGFuZ2UgPSBvbkNoYW5nZSk7XG5cblx0cHVibGljIHJlZ2lzdGVyT25Ub3VjaGVkID0gKG9uVG91Y2hlZDogKCkgPT4gdm9pZCkgPT5cblx0XHQodGhpcy5vblRvdWNoZWQgPSBvblRvdWNoZWQpO1xuXG5cdHB1YmxpYyBzZXREaXNhYmxlZFN0YXRlID0gKGRpc2FibGVkOiBib29sZWFuKSA9PiB7XG5cdFx0aWYgKHRoaXMucmVnaXN0ZXJlZCkgdGhpcy5kaXNhYmxlZCQuc2V0KGRpc2FibGVkKTtcblx0fTtcbn1cbiJdfQ==